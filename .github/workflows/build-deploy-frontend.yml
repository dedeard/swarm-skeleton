name: Build and Deploy Frontend

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'yarn.lock'
      - 'Dockerfile*'
      - '.github/workflows/build-deploy-frontend.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'yarn.lock'
      - 'Dockerfile*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_deploy:
        description: 'Skip deployment (build only)'
        required: false
        default: false
        type: boolean

jobs:
  # Call the fetch-secrets workflow to get secrets from Key Vault
  fetch-secrets:
    name: Fetch Secrets from Key Vault
    permissions:
      id-token: write # Allow the called workflow to request OIDC tokens
      contents: read  # Allow the called workflow to have read access to contents
    uses: ./.github/workflows/fetch-secrets.yml
    with:
      environment: ${{ github.event.inputs.environment || 'staging' }}
    secrets: inherit

  build:
    name: Build Frontend Docker Image
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC to Azure
      contents: read # Default, good to keep if other permissions are set
      packages: write # Required for docker/build-push-action to push to ACR if ACR is GitHub Packages
    environment: ${{ github.event.inputs.environment || 'staging' }}
    needs: fetch-secrets
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ needs.fetch-secrets.outputs.acr_login_server }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Prepare Build Variables
        id: vars
        run: |
          # Extract environment from workflow input or default to staging
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          
          # Define image name based on environment
          FRONTEND_IMAGE="${{ needs.fetch-secrets.outputs.acr_login_server }}/frontend:${ENVIRONMENT}-${GITHUB_SHA::8}"
          
          # Set outputs for later steps
          echo "frontend_image=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

      # Build and push frontend image
      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.vars.outputs.frontend_image }}
          cache-from: type=registry,ref=${{ steps.vars.outputs.frontend_image }}
          cache-to: type=inline
          build-args: |
            ENVIRONMENT=${{ steps.vars.outputs.environment }}
            VITE_API_URL=${{ needs.fetch-secrets.outputs.api_url }}

      # Update latest tag for the environment
      - name: Tag image as latest for environment
        run: |
          # Tag frontend
          docker tag ${{ steps.vars.outputs.frontend_image }} ${{ needs.fetch-secrets.outputs.acr_login_server }}/frontend:${{ steps.vars.outputs.environment }}-latest
          docker push ${{ needs.fetch-secrets.outputs.acr_login_server }}/frontend:${{ steps.vars.outputs.environment }}-latest

      # Create a deployment summary
      - name: Build Summary
        run: |
          echo "## Frontend Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Environment: ${{ steps.vars.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Image |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | \`${{ steps.vars.outputs.frontend_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This image is also tagged as \`${{ steps.vars.outputs.environment }}-latest\` for deployment." >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC to Azure
      contents: read # Required for checkout
    needs: [fetch-secrets, build]
    if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (github.event.inputs.skip_deploy != 'true') }}
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout Infrastructure Repo
        uses: actions/checkout@v3
        with:
          repository: Swarm-by-CHI/swarm-deployement
          path: infrastructure
          token: ${{ secrets.INFRA_REPO_PAT }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.3.0

      - name: Install Terragrunt
        run: |
          wget -O terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v0.45.0/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Prepare environment
        id: env
        run: |
          # Determine environment from workflow input or from context
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          
          # Create a .tfvars file with updated image tags
          cd infrastructure
          mkdir -p $ENVIRONMENT
          
          cat > $ENVIRONMENT/frontend.auto.tfvars <<EOF
          container_images = {
            "frontend" = "${{ needs.fetch-secrets.outputs.acr_login_server }}/frontend:$ENVIRONMENT-latest"
          }
          EOF
          
          # Output for later steps
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

      - name: Terragrunt Init
        run: |
          cd infrastructure/${{ steps.env.outputs.environment }}
          terragrunt init

      - name: Terragrunt Plan
        run: |
          cd infrastructure/${{ steps.env.outputs.environment }}
          terragrunt plan -out=tfplan

      - name: Terragrunt Apply
        run: |
          cd infrastructure/${{ steps.env.outputs.environment }}
          terragrunt apply -auto-approve tfplan

      - name: Generate Deployment Summary
        run: |
          cd infrastructure/${{ steps.env.outputs.environment }}
          
          # Extract frontend URL from outputs if available
          echo "## Frontend Deployment Summary for ${{ steps.env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Try to extract the frontend URL from terraform outputs
          if terragrunt output -raw frontend_url 2>/dev/null; then
            echo "Frontend URL: $(terragrunt output -raw frontend_url)" >> $GITHUB_STEP_SUMMARY
          else
            echo "Frontend deployed successfully to ${{ steps.env.outputs.environment }} environment" >> $GITHUB_STEP_SUMMARY
          fi
